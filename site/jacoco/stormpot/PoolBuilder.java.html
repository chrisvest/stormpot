<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PoolBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stormpot</a> &gt; <a href="index.source.html" class="el_package">stormpot</a> &gt; <span class="el_source">PoolBuilder.java</span></div><h1>PoolBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright © 2011-2019 Chris Vest (mr.chrisvest@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package stormpot;

import java.util.Map;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

import static java.util.Objects.requireNonNull;
import static java.util.concurrent.TimeUnit.MINUTES;
import static stormpot.AllocationProcessMode.*;
import static stormpot.Expiration.after;
import static stormpot.Expiration.never;
import static stormpot.StormpotThreadFactory.INSTANCE;

/**
 * The `PoolBuilder` collects information about how big a pool should be,
 * and how it should allocate objects, an so on, and finally acts as the
 * factory for building the pool instances themselves, with the
 * {@link #build()} method.
 *
 * Pool builder instances are obtained by calling one of the `from*`
 * methods on {@link Pool}, such as {@link Pool#fromThreaded(Allocator)}.
 *
 * This class is made thread-safe by having the fields be protected by the
 * intrinsic object lock on the `PoolBuilder` object itself. This way, pools
 * can `synchronize` on the builder object to read the values out atomically.
 *
 * The various set* methods are made to return the `PoolBuilder` instance
 * itself, so that the method calls may be chained if so desired.
 * 
 * @author Chris Vest &lt;mr.chrisvest@gmail.com&gt;
 * @param &lt;T&gt; The type of {@link Poolable} objects that a {@link Pool} based
 * on this `PoolBuilder` will produce.
 */
public final class PoolBuilder&lt;T extends Poolable&gt; implements Cloneable {
<span class="fc" id="L50">  static final Map&lt;AllocationProcessMode, PoolBuilderDefaults&gt; DEFAULTS = Map.of(</span>
<span class="fc" id="L51">      THREADED, new PoolBuilderDefaults(after(8, 10, MINUTES), INSTANCE, true, true, 1000),</span>
<span class="fc" id="L52">      INLINE, new PoolBuilderDefaults(after(8, 10, MINUTES), INSTANCE, true, false, 0),</span>
<span class="fc" id="L53">      DIRECT, new PoolBuilderDefaults(never(), INSTANCE, false, false, 0)</span>
  );

<span class="fc" id="L56">  static final Map&lt;AllocationProcessMode, PoolBuilderPermissions&gt; PERMISSIONS = Map.of(</span>
      THREADED, new PoolBuilderPermissions(true, true, true, true, true),
      INLINE, new PoolBuilderPermissions(true, true, true, false, false),
      DIRECT, new PoolBuilderPermissions(false, true, false, false, false)
  );

  private final AllocationProcess allocationProcess;
  private final PoolBuilderPermissions permissions;
  private Allocator&lt;T&gt; allocator;
<span class="fc" id="L65">  private int size = 10;</span>
  private Expiration&lt;? super T&gt; expiration;
  private MetricsRecorder metricsRecorder;
  private ThreadFactory threadFactory;
  private boolean preciseLeakDetectionEnabled;
  private boolean backgroundExpirationEnabled;
  private int backgroundExpirationCheckDelay;

  /**
   * Build a new empty `PoolBuilder` object.
   */
<span class="fc" id="L76">  PoolBuilder(AllocationProcess allocationProcess, Allocator&lt;T&gt; allocator) {</span>
<span class="fc" id="L77">    requireNonNull(allocator, &quot;The Allocator cannot be null.&quot;);</span>
<span class="fc" id="L78">    requireNonNull(allocationProcess, &quot;The AllocationProcess cannot be null.&quot;);</span>
<span class="fc" id="L79">    this.allocator = allocator;</span>
<span class="fc" id="L80">    this.allocationProcess = allocationProcess;</span>
<span class="fc" id="L81">    this.permissions = PERMISSIONS.get(allocationProcess.getMode());</span>
<span class="fc" id="L82">    PoolBuilderDefaults defaults = DEFAULTS.get(allocationProcess.getMode());</span>
<span class="fc" id="L83">    this.expiration = defaults.expiration;</span>
<span class="fc" id="L84">    this.threadFactory = defaults.threadFactory;</span>
<span class="fc" id="L85">    this.preciseLeakDetectionEnabled = defaults.preciseLeakDetectionEnabled;</span>
<span class="fc" id="L86">    this.backgroundExpirationEnabled = defaults.backgroundExpirationEnabled;</span>
<span class="fc" id="L87">    this.backgroundExpirationCheckDelay = defaults.backgroundExpirationCheckDelay;</span>
<span class="fc" id="L88">  }</span>

  /**
   * Set the size of the pool we are building.
   *
   * Pools are required to control the allocations and deallocations, such that
   * no more than this number of objects are allocated at any time.
   *
   * This means that a pool of size 1, whose single object have expired, will
   * deallocate that one object before allocating a replacement.
   *
   * The size must be at least one, or an {@link IllegalArgumentException} will
   * be thrown when building the pool.
   *
   * Note that the pool size can be modified after the pool has been built, by
   * calling the {@link Pool#setTargetSize(int)} or
   * {@link ManagedPool#setTargetSize(int)} methods.
   *
   * @param size The target pool size. Must be at least 0.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setSize(int size) {
<span class="fc" id="L110">    checkPermission(permissions.setSize, &quot;size&quot;);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">    if (size &lt; 0) {</span>
<span class="fc" id="L112">      throw new IllegalArgumentException(&quot;Size must be at least 0, but was &quot; + size + &quot;.&quot;);</span>
    }
<span class="fc" id="L114">    this.size = size;</span>
<span class="fc" id="L115">    return this;</span>
  }

  /**
   * Get the currently configured size. The default is 10.
   * @return The configured pool size.
   */
  public synchronized int getSize() {
<span class="fc" id="L123">    return size;</span>
  }

  /**
   * Set the {@link Allocator} or {@link Reallocator} to use for the pools we
   * want to configure. This will change the type-parameter of the `PoolBuilder`
   * object to match that of the new Allocator.
   *
   * The allocator is initially specified by the {@link Pool#from(Allocator)}
   * method, so there is usually no need to set it later.
   *
   * @param allocator The allocator we want our pools to use.
   * This cannot be `null`.
   * @param &lt;X&gt; The type of {@link Poolable} that is created by the allocator,
   * and the type of objects that the configured pools will contain.
   * @return This `PoolBuilder` instance, but with a generic type parameter that
   * matches that of the allocator.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public synchronized &lt;X extends Poolable&gt; PoolBuilder&lt;X&gt; setAllocator(
      Allocator&lt;X&gt; allocator) {
<span class="fc" id="L144">    checkPermission(permissions.setAllocator, &quot;allocator&quot;);</span>
<span class="fc" id="L145">    requireNonNull(allocator, &quot;The Allocator cannot be null.&quot;);</span>
<span class="fc" id="L146">    this.allocator = (Allocator&lt;T&gt;) allocator;</span>
<span class="fc" id="L147">    return (PoolBuilder&lt;X&gt;) this;</span>
  }

  /**
   * Get the configured {@link Allocator} instance.
   * @return The configured Allocator instance.
   */
  public synchronized Allocator&lt;T&gt; getAllocator() {
<span class="fc" id="L155">    return allocator;</span>
  }

  /**
   * Get the configured {@link stormpot.Allocator} instance as a
   * {@link stormpot.Reallocator}. If the configured allocator implements the
   * Reallocator interface, then it is returned directly. Otherwise, the
   * allocator is wrapped in an adaptor.
   * @return A configured or adapted Reallocator.
   */
  public synchronized Reallocator&lt;T&gt; getReallocator() {
<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (allocator instanceof Reallocator) {</span>
<span class="fc" id="L167">      return (Reallocator&lt;T&gt;) allocator;</span>
    }
<span class="fc" id="L169">    return new ReallocatingAdaptor&lt;&gt;(allocator);</span>
  }

  /**
   * Set the {@link Expiration} to use for the pools we want to
   * configure. The Expiration determines when a pooled object is valid
   * for claiming, or when the objects are invalid and should be deallocated.
   *
   * The default Expiration is an
   * {@link Expiration#after(long, long, TimeUnit)} that invalidates the
   * objects after they have been active for somewhere between 8 to 10 minutes.
   *
   * @param expiration The expiration we want our pools to use. Not null.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setExpiration(Expiration&lt;? super T&gt; expiration) {
<span class="fc" id="L185">    checkPermission(permissions.setExpiration, &quot;expiration&quot;);</span>
<span class="fc" id="L186">    requireNonNull(expiration, &quot;Expiration cannot be null.&quot;);</span>
<span class="fc" id="L187">    this.expiration = expiration;</span>
<span class="fc" id="L188">    return this;</span>
  }

  /**
   * Get the configured {@link Expiration} instance. The default is a
   * {@link Expiration#after(long, long, TimeUnit)} that expires objects after
   * somewhere between 8 to 10 minutes.
   *
   * @return The configured Expiration.
   */
  public synchronized Expiration&lt;? super T&gt; getExpiration() {
<span class="fc" id="L199">    return expiration;</span>
  }

  /**
   * Set the {@link MetricsRecorder} to use for the pools we want to configure.
   * @param metricsRecorder The MetricsRecorder to use, or null if we don't
   *                        want to use any.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setMetricsRecorder(MetricsRecorder metricsRecorder) {
<span class="fc" id="L209">    this.metricsRecorder = metricsRecorder;</span>
<span class="fc" id="L210">    return this;</span>
  }

  /**
   * Get the configured {@link MetricsRecorder} instance, or null if none has
   * been configured.
   * @return The configured MetricsRecorder.
   */
  public synchronized MetricsRecorder getMetricsRecorder() {
<span class="fc" id="L219">    return metricsRecorder;</span>
  }

  /**
   * Get the ThreadFactory that has been configured, and will be used to create
   * the background allocation threads for the pools. The default is similar to
   * the {@link java.util.concurrent.Executors#defaultThreadFactory()}, except
   * the string &quot;Stormpot-&quot; is prepended to the thread name.
   * @return The configured thread factory.
   */
  public synchronized ThreadFactory getThreadFactory() {
<span class="fc" id="L230">    return threadFactory;</span>
  }

  /**
   * Set the ThreadFactory that the pools will use to create its background
   * threads with. The ThreadFactory is not allowed to be null, and creating
   * a pool with a null ThreadFactory will throw an IllegalArgumentException.
   * @param factory The ThreadFactory the pool should use to create their
   *                background threads.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setThreadFactory(ThreadFactory factory) {
<span class="fc" id="L242">    checkPermission(permissions.setThreadFactory, &quot;thread factory&quot;);</span>
<span class="fc" id="L243">    requireNonNull(factory, &quot;ThreadFactory cannot be null.&quot;);</span>
<span class="fc" id="L244">    threadFactory = factory;</span>
<span class="fc" id="L245">    return this;</span>
  }

  /**
   * Return whether or not precise object leak detection is enabled, which is
   * the case by default.
   * @return `true` if precise object leak detection is enabled.
   * @see #setPreciseLeakDetectionEnabled(boolean)
   */
  public synchronized boolean isPreciseLeakDetectionEnabled() {
<span class="fc" id="L255">    return preciseLeakDetectionEnabled;</span>
  }

  /**
   * Enable or disable precise object leak detection. It is enabled by default.
   * Precise object leak detection makes the pool keep an eye on the allocated
   * Poolables, such that it notices if they get garbage collected without
   * first being deallocated. Using the garbage collector for this purpose,
   * means that no false positives (counting objects as leaked, even though
   * they are not) are ever reported.
   *
   * [NOTE]
   * --
   * While the pool is able to detect object leaks, it cannot prevent
   * them. All leaks are a sign that there is a bug in the system; most likely
   * a bug in your code, or in the way the pool is used.
   * --
   *
   * Precise object leak detection incurs virtually no overhead, and is safe to
   * leave enabled at all times – even in the most demanding production
   * environments.
   *
   * @param enabled `true` to turn on precise object leak detection (the
   *                default) `false` to turn it off.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setPreciseLeakDetectionEnabled(boolean enabled) {
<span class="fc" id="L282">    this.preciseLeakDetectionEnabled = enabled;</span>
<span class="fc" id="L283">    return this;</span>
  }

  /**
   * Return whether or not background expiration is enabled.
   * By default, background expiration is enabled.
   *
   * @return `true` if background expiration is enabled.
   * @see #setBackgroundExpirationEnabled(boolean)
   */
  public synchronized boolean isBackgroundExpirationEnabled() {
<span class="fc" id="L294">    return backgroundExpirationEnabled;</span>
  }

  /**
   * Enable or disable background object expiration checking. This is enabled
   * by default, but can be turned off if the check is expensive.
   * The cost of the check matters because it might end up taking resources
   * away from the background thread and hinder its ability to keep up with the
   * demand for allocations and deallocations, even though these tasks always
   * take priority over any expiration checking.
   *
   * @param enabled `true` (the default) to turn background expiration checking on,
   *               `false` to turn it off.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setBackgroundExpirationEnabled(boolean enabled) {
<span class="fc" id="L310">    checkPermission(permissions.setBackgroundExpiration, &quot;background expiration enabled/disabled&quot;);</span>
<span class="fc" id="L311">    backgroundExpirationEnabled = enabled;</span>
<span class="fc" id="L312">    return this;</span>
  }

  /**
   * Return the default approximate delay, in milliseconds, between background
   * maintenance tasks, such as the background expiration checks and retrying
   * failed allocations.
   *
   * @return the delay, in milliseconds, between background maintenance tasks.
   */
  public synchronized int getBackgroundExpirationCheckDelay() {
<span class="fc" id="L323">    return backgroundExpirationCheckDelay;</span>
  }

  /**
   * Set the approximate delay, in milliseconds, between background maintenance tasks.
   * These tasks include the background expiration checks, and retrying failed allocations.
   *
   * The default delay is 1.000 milliseconds (1 second). Lowering this value will
   * improve the pools responsiveness to repairing failed allocations, and also increase
   * the frequency of the background expiration checks. This comes at the cost of higher
   * idle CPU usage.
   *
   * It is not recommended to set this value lower than 100 milliseconds. Values lower
   * than this tend to have increased CPU and power usage, for very little gain in
   * responsiveness for the background tasks.
   *
   * @param delay the desired delay, in milliseconds, between background maintenance tasks.
   * @return This `PoolBuilder` instance.
   */
  public synchronized PoolBuilder&lt;T&gt; setBackgroundExpirationCheckDelay(int delay) {
<span class="fc" id="L343">    checkPermission(permissions.setBackgroundExpiration, &quot;background expiration check delay&quot;);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">    if (delay &lt; 0) {</span>
<span class="fc" id="L345">      throw new IllegalArgumentException(&quot;Background expiration check delay cannot be negative.&quot;);</span>
    }
<span class="fc" id="L347">    backgroundExpirationCheckDelay = delay;</span>
<span class="fc" id="L348">    return this;</span>
  }

  /**
   * Returns a shallow copy of this `PoolBuilder` object.
   * @return A new `PoolBuilder` object of the exact same type as this one, with
   * identical values in all its fields.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public final synchronized PoolBuilder&lt;T&gt; clone() {
    try {
<span class="fc" id="L360">      return (PoolBuilder&lt;T&gt;) super.clone();</span>
<span class="nc" id="L361">    } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L362">      throw new AssertionError(e);</span>
    }
  }

  /**
   * Build a {@link Pool} instance based on the collected configuration.
   * @return A {@link Pool} instance as configured by this builder.
   */
  public synchronized Pool&lt;T&gt; build() {
<span class="fc" id="L371">    return new BlazePool&lt;&gt;(this, allocationProcess);</span>
  }

  /**
   * Returns a `Reallocator`, possibly by adapting the configured
   * `Allocator` if need be.
   * If a `MetricsRecorder` has been configured, the return `Reallocator` will
   * automatically record allocation, reallocation and deallocation latencies.
   */
  synchronized Reallocator&lt;T&gt; getAdaptedReallocator() {
<span class="fc bfc" id="L381" title="All 2 branches covered.">    if (metricsRecorder == null) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">      if (allocator instanceof Reallocator) {</span>
<span class="fc" id="L383">        return (Reallocator&lt;T&gt;) allocator;</span>
      }
<span class="fc" id="L385">      return new ReallocatingAdaptor&lt;&gt;(allocator);</span>
    } else {
<span class="fc bfc" id="L387" title="All 2 branches covered.">      if (allocator instanceof Reallocator) {</span>
<span class="fc" id="L388">        return new TimingReallocatorAdaptor&lt;&gt;(</span>
            (Reallocator&lt;T&gt;) allocator, metricsRecorder);
      }
<span class="fc" id="L391">      return new TimingReallocatingAdaptor&lt;&gt;(allocator, metricsRecorder);</span>
    }
  }

  private void checkPermission(boolean permission, String fieldDescription) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">    if (!permission) {</span>
<span class="fc" id="L397">      String message = &quot;The &quot; + allocationProcess.getMode() + &quot; allocation process does &quot; +</span>
          &quot;not support configuring the &quot; + fieldDescription + &quot;.&quot;;
<span class="fc" id="L399">      throw new IllegalStateException(message);</span>
    }
<span class="fc" id="L401">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>